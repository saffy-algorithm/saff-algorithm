# 순서대로 위 왼 오 세팅
# 0 : 상, 1 : 좌, 2 : 우     
dr = [-1, 0, 0] # 행의 변화량
dc = [0, -1, 1] # 열의 변화량

# 각 방향에서 다음 탐색 우선순위
# dir = 0 (위쪽) : 먼저 왼쪽(1), 오른쪽(2), 확인 후 위(0)
# dir = 1 (왼쪽) : 왼쪽(1) 유지 가능하면 계속, 아니면 위(0) 
# dir = 2 (오른쪽) : 오른쪽(2) 유지 가능하면 계속, 아니면 위(0)

# 0 : [1, 2, 0]
# 1 : [0, 1]
# 2 : [0, 2]
search_dir = [[1, 2, 0], [0, 1], [0, 2]]

T = 10
for tc in range(1, T+1):
    input()
    ladder = [list(map(int,input().split())) for _ in range (100)] # 리스트 몇바이몇인지

# 100x100 사다리 배열 입력
# 출구부터 거꾸로 올라갈거임
    r = 99
    # 마지막 줄에서 2의 위치
    c = ladder[99].index(2) # 2의 위치 찾는 건 index 함수 써줌
    
# 이동을 위해서는 방향을 정해줘야 함
# 현재 방향을 나타내는 변수
    dir = 0 # 초기값 0
    
# 이동을 반복해서 수행 -> 이동 횟수 알 수 없음 -> 알 수 없으면 while
# 언제까지 while 을 도냐 -> 입구까지 가면 중단
# 입구라는 건 어떻게 ? -> r=0이면 
# r이 0이 되기 전까지 돌아야 함 (즉, 맨 윗줄에 도착할 때까지 반복)

# 이제 출발 ㄱ
    while r > 0:
# 우선순위에 따라서 탐색 -> 현재 바라보는 방향에 따라서 달라짐
        # 다음 방향 탐색
        for i in range(len(search_dir[dir])): # 인덱스로 현재방향을 넣어줌
            # 다음 방향 후보
            next_dir = search_dir[dir][i]
            # 다음 이동할 좌표 계산
            next_r = r+dr[next_dir]
            next_c = c+dc[next_dir]
            
            # 확정지을 수 없음
            # 이동 가능 여부 확인
            # 조건
            if 0 <= next_c < 100 and ladder[next_r][next_c] == 1:
                dir = next_dir # 다음후보 확정시켜줌
                r = next_r
                c = next_c
                break
            
    print(f'#{tc} {c}')